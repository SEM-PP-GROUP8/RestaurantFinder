Title page

 
Abstract

 

Table of contents
INTRODUCTION	1
BACKGROUND ?KIKE?	1
PURPOSE ?KIKE?	1
MATERIAL ?HAMPUS?	1
METHOD- SERGIU?	1
BODY/RESULT ?ALL?	2
CONCLUSION AND DISSCUSION ?ALL?	3
SOURCES ?KEVIN?	4


 
Introduction

Background
With many types of resources in the area, with plenty of seafood from the coast, fresh vegetables form the south and mushrooms from the northeast it is not weird that Gothenburg is rich in its food culture. There are more than 650 restaurants in the Gothenburg city area and over 300 more restaurants in the surrounding areas, so Gothenburg is definitely a restaurant rich city.  There are four exclusive Michelin stars awarded restaurants. There are plenty of streets that are food and entertainment oriented and the culture incentivizes you to enjoy them. With the classis Swedish fika, the brunch, lunch and dinner, restaurants and cafes have a big influence in the social life of the Gothenburg inhabitants.
Purpose
The purpose of the project is to have a more centralized and simple way to find the type of restaurant you want to visit at a specific point in time.  The application will help the customer find a restaurant based on different parameters. It will also provide a way to rate them and to store those reviews in order to remember which restaurants they have visited and what they thought about it. From the restaurant owner point of view, the application will help the owner to see first hand what customers thought about their experience and to modify the information provided along with the restaurant.  The application is targeted for restaurant owner who want to reach their customers in a better way and for people who want a tool to find the right restaurant experience they were looking for.
	
	Material ?Hampus?
Several tools were used to help with the development of the project, with the main tool for developing the application being netbeans. This IDE was chosen mostly because of the GUI building feature, but proved useful in other areas as well, like the support for maven, which was used to organize imported packages. Maven did, however, make it difficult for the group to make an executable file of the program, so time was spent on fixing this, which the group did not expect. The GUI  building feature also proved to have some negative features. The auto generated code, for instance, was sometimes hard to manage due to the lack of editing support.

Because of the lack of experience in software development, educational and informational sources such as stackoverflow and java documentation, proved to be highly valuable. Without either of these, the development of the application would not have been as successful. Stackoverflow, along with other websites such as youtube and various forums, were especially important due to the amount of experience amongst the people contributing their knowledge.

For communication, facebook was the main tool. The possibility to create groups and chatting was of great use, but since facebook contains a lot of content unrelated to the group, it was not optimal to use. For example, during a chatting session team members could a lot of times be interrupted by people outside the group wanting to chat with them, or the content posted on facebook could be distracting. The other only communicational tools, was email and texting, which was not used very much.

Facebook and email, along with dropbox for a short period of time, were the tools used for version control through most of the development. At first this method was working, but after a while it became very messy, and around the beta demonstration, an error occurred due to the amont of version of the application available. Despite this error, facebook and email remained as the main tools for version control, until the end of the development, in the debugging phase, where the group decided to use github, which had a large effect on the productivity. Github helpt not only with version control, but with the commitment amongst team members.
	
	Method- Sergiu?

Spring
MVC

Agile process
Given the nature of the project, 
Scrum


 
Body/result ?ALL?

Initial thoughts on software process
Our initial choice of a software process was agile, due to the fact that the developing team was inexperienced. 
Due to the fact that the team was inexperienced, the risk of requirements and design changes was pretty high. In order to minimize it, agile was the adequate choice as a software process. Incremental approach was proposed as a common technique of development for all members, but each member could tailor their own process when working on the scheduled tasks.
A team leader has not been chosen since none of us possessed enough knowledge to take this responsibility. 

Problem ?cause ?solution discussions section:

Structure: Problem, cause (What caused the problem), solution (which was applied, or should have been applied).

Any or all of the subparts (problem/cause/solution) should be detailed.
[SERGIU START]
Since the responsibility was declared equal, yet ambigous, among team members, it proved difficult to assign specific tasks in the project plan to one member or another. Together with the team not being lead by someone, it resulted in generating a schedule with broad and unassignable goals.
Instead of refering to "fundamental requirements" in the project estimates chapter, requirements should have been specified in such a matter that, "X feature shall be designed by Y member by the Z date". "Translator component is developed for the other team" should have mentioned more detailed individual phases, similar to those of software development. Thus specifying components or phases in detail, assigning the responsibility and scheduling deadlines for their completion would have increased the quality of work, productivity and enabled proper monitoring of the project's progress.
Another negative affect of not assigning roles is that the project plan has never been updated for the second phase, which was described as the period after the beta presentation deadline. Phase two of the estimates chapter describes yet again very broad activities such as further requirements engineering, implementation, testing and deployment. The fact that installation and usage documentation needed to be written or cross platform testing needed to be done were completely left out. Apart from inexperience, a major contributor to this particular issue was lack of time, as it was written very close to the submission deadline. As previously mentioned earlier, the solution would have been better management: someone to be our leader.

Revision control proved challenging. As the team started developing the application in Netbeans, the process of publishing the update supposed exporting the project to a zip file and updating it to Facebook mentioning the changes that were made. Eventually multiple different versions of the application were produced in a short amount of time. Significant resources were wasted on making sure the application a member was working on was up to date with the rest of the team's versions. And even so, there was a case of further development being committed on a bugged version, even though the bug was fixed at some point.
Another disadvantage of not using version control software, is that every member had to work strictly on what they were responsible for, unless they talked with another member or the entire team. For instance if one member was working on the "Restaurant Edit View" and one on the "Search View", one could not modify a component on which both views would be dependant (i.e. RestaurantDAO, SQLTranslator, DBHandler) without making sure the other person would accept that.
Github was introduced rather late in the project, but it was essential for the project's success. Productivity, cooperation and quality increased drastically as work could done safely on almost any part of the system.

Test driven development has been proposed initially for all its benefits. It would allow the team to easily test the whole application making sure that any new implementation of features do not affect other parts of the system. It also encourages use case writing, minimal risk of bugs being introduced and clean interfaces. 
Despite the compelling benefits, the team had no knowledge on how to adopt this practice. Small time frame combined with having higher priority tools and methods that required training as well, determined the practice of test driven development to be quickly abandoned from the very beginning of the project.
Due to the many bugs being easily introduced in the system, especially in new components, identifying and correcting mistakes most often than not consumed more resources than writing the initial code. It is obvious now that this practice's implementation should have been given higher priority. Better management may have allowed more resources to be invested in training. Inclusion of this practice to be taught at one of the courses would have been also helpful.

Division of work was naive in the beginning. With a not-so-detailed list of requirements, the team comprised of four members was split into two, one half had to handle the front-end and the other half the back-end. Due to lack of communication and the members being eager to start coding, both teams ended up developing both front-end and back-end parts of the application. The team reassessed the way it was distributing work among members and concluded it needed to follow an architectural pattern: Model-View-Controller.

The separation of concerns that MVC enforces enabled the team to distribute work by views, thus each member had to work on a specific view, developing its controller and models. If work was affecting common components (such as data related classes, main controller) the team would have to get together and talk about an appropriate solution.
[SERGIU STOP]
[HAMPUS START]
-	We lacked a team leader. 
-	We needed a more specific and tailored software process to follow.
a.	What did we miss out exactly?
b.	We needed more prototyping
c.	We needed an iterative-incremental approach
-	A lot of work was invested for developing simple functionality. The use of netbeans?window builder and spring framework were proposed for minimizing boiler plate coding.

-	Tools that were identified to increase productivity were not used. Training proved challenging and time consuming. They were identified late in the project. They should have been identified right from the start so that there would be enough time for training.
[HAMPUS STOP]

[KIKE START]
-	Dependency handling proved difficult. [give examples for when we needed solution for automatic dependency handling]. [explain that Maven was used]
Dependency handling proved difficult
Dependency handling proved difficult for the project when the group decided to move to a MVC framework. The whole idea behind MVC was that it was possible to modulate views controllers and the data modules in different classes so that all the group members could make increments in different views. The division of work had proven a challenge and therefore it was needed to arrive to a better way of working as a group. 
When there are so many modules being worked on at the same time using different libraries and maybe different versions of the same library some errors could arrive. A more specific example came with the release of JDK 1.8 where the java.Time.Format package was included. One of the latest classes was using this and therefore some of the computers being used could not run the program. This because the IDE does not automatically download all the required elements, but rather just checks its installed JDK for the referred library. Another scenario is when newer versions of libraries deprecate a specific method on a newer version. If the method is being used in the program it can cause errors. Therefore a specific version of the library needs to be able to be specified in the program execution. 
Maven was chosen as the tool to manage the dependencies both because it is highly used in real life workplaces but also because it is already integrated in Netbeans.  Maven allowed that with a click of a button all the necessary dependencies, both the right library but also the specific version, where downloaded into the project file. 

-	Sprint workflow inspired from SCRUM was introduced later in the project. [why was it needed?] [examples of cases when it could have been used]
Sprint workflow inspired from SCRUM was introduced later in the projectAfter the beta version was presented the group agreed that the software process we were using was ineffective. Communication was not at its best within the group, the division of labor proved to be difficult and the tasks assigned where too general. Because of its highly agile structure, and its recurrent meetings Scrum seemed the perfect choice as a software process. The team decided to meet twice a week, on Mondays and on Thursdays around noon and have a meeting for two hours to talk about the increment during the week and to see if new tasks could be handed out.  The sprint would be measured on a weekly basis (Mondays) and the progress and challenges discussed during the sprint. 	This software process increased the productivity significantly since there was a much better and faster division of tasks. Also it helped the members of the group to support each other on difficulties they were facing. Most importantly changes on the structure of the program could be addressed in a timely manner and therefore it saved a lot of time that could have been wasted on unnecessary coding.
-	Database sharing. Solution was having it hosted.
-	We were not sure about the right language to use for developing the application. WE chose java because blablabla
[KIKE STOP]

[KEVIN START]
going to starting working on it :)
-	We had difficulty choosing a database system. SQLite was recommended. Inexperience. We chose mysql because:
o	We wanted it to be remote
o	More documentation out there
o	More relevant career wise
o	Some of the members had previous experience with mysql

-	GUI was not consistent between different platforms, particularly OSX vs Windows. Caused by the operating systems?way of displaying graphical elements. Certain components had to be changed from the initial design specification.
-	Issue with merging window builder generated code and resolving version control conflict. Solution: we decided to make sure we’re not working on the same components at the same time, otherwise we had to use another text editor than netbeans, as netbeans does not allow to modify generated code by window builder.
-	We avoided the concept of a stakeholder. The project requirements were broad. We think the scrum framework should be enforced by the course from the beginning. It will force us to treat our teacher and supervisor as a stakeholders and also force us to involve the stakeholders in the development process. Also the requirements would be a bit more refined and guessing requirements would be minimized.
[KEVIN STOP]
	
STORYLINE OF GROUP TASK DIVISION AND THE GROUP LOGS
Pre-Beta Version
The initial process was to divide the group into two teams. One team would take care of the GUI and the other team would set up the database. This structure was used in the mentioned incremental approach with only Facebook as a communication tool. Version control was practically non-existent. Because of correlation between the database and the program itself both teams were crossing borders all the time and trying to do what was needed to finish a part of its own team. So for example the database team did some GUI because they needed to try out their database and the GUI team did a bit of the database because they needed to test their GUI. 
Beta Version
At the time the beta consisted of a database with the users, owners, and administrators table and the restaurants table. There would be a capability to filter the restaurant through different possibilities and there would be an option to add and delete restaurants. Also the users would be able to log in and out of the program and they would be able to register as new users.
Post-Beta Version
After the beta version, we received some feedback from our classmates on things to improve. The group acknowledged the fact that a lot of how things were done was not very productive. The team decided to move towards the MVC pattern basing our project on the Spring framework. Maven would be used as a dependency tool and the group would work using SCRUM as the software process. Also it was agreed better communication through the Facebook group was needed and that meetings would happen twice a week on Mondays and on Thursdays to discuss the advance and to distribute new tasks.
Final Version
	By this point the advance was much better. The biweekly meetings helped to update on what advancements where being done. There was a decision to start working more closely on version control. Because of the lack of sharing of versions, the task to put the application together was becoming a nightmare. At the ends there would be four people making updates from different fronts and therefore a better version control method was needed. The group decided to adopt Guthub as the version control manager and the application grew and got debugged at a very fast pace.



what you did
how you did it

 
Conclusion and disscusion ?ALL?

- what major problems you faced
- how you overcame these
- how would we do it differently?
 
Sources ?Kevin?

